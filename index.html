<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voice Inventory</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, system-ui, sans-serif;
            background: #0d0d0d;
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .status {
            color: #00ff88;
            font-size: 1.1rem;
            font-weight: 600;
            min-height: 30px;
        }

        /* MIC BUTTON */
        .mic-section {
            text-align: center;
            margin-bottom: 30px;
        }

        .mic-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: none;
            background: #00ff88;
            color: #000;
            font-size: 2.5rem;
            cursor: pointer;
            transition: 0.2s;
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.3);
        }

        .mic-btn.listening {
            background: #ff3366;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .transcript {
            margin-top: 15px;
            padding: 15px;
            background: #1a1a1a;
            border-radius: 10px;
            min-height: 50px;
            color: #00ff88;
            font-size: 1.1rem;
            text-align: center;
        }

        /* CONTROLS */
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
        }

        .control-btn {
            flex: 1;
            padding: 15px;
            background: #1a1a1a;
            border: 2px solid #333;
            color: #fff;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: 0.2s;
        }

        .control-btn:active {
            background: #2a2a2a;
            transform: scale(0.98);
        }

        /* FORM */
        .form {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }

        .field-group {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #333;
            transition: 0.2s;
        }

        .field-group.active {
            border-left-color: #00ff88;
            background: #1f2a1f;
        }

        .field-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .field-number {
            color: #00ff88;
            font-weight: 700;
        }

        .field-input {
            width: 100%;
            background: none;
            border: none;
            color: #fff;
            font-size: 1.4rem;
            font-weight: 600;
            outline: none;
            padding: 0;
        }

        .field-input::placeholder {
            color: #444;
        }

        /* SAVE BUTTON */
        .save-btn {
            width: 100%;
            padding: 20px;
            background: #00ff88;
            color: #000;
            border: none;
            border-radius: 12px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            margin-bottom: 20px;
            transition: 0.2s;
        }

        .save-btn:active {
            transform: scale(0.98);
        }

        .save-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* LOG */
        .log {
            background: #1a1a1a;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .log-header {
            padding: 15px 20px;
            background: #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .log-count {
            background: #00ff88;
            color: #000;
            padding: 4px 12px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 0.9rem;
        }

        .log-items {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s;
        }

        .log-items.open {
            max-height: 400px;
            overflow-y: auto;
        }

        .log-item {
            padding: 15px 20px;
            border-bottom: 1px solid #222;
        }

        .log-item-name {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 5px;
        }

        .log-item-details {
            font-size: 0.85rem;
            color: #888;
        }

        /* HELP */
        .help {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #00ff88;
        }

        .help h3 {
            color: #00ff88;
            margin-bottom: 15px;
            font-size: 1rem;
        }

        .help ul {
            list-style: none;
            line-height: 2;
            color: #aaa;
        }

        .help li::before {
            content: "‚Üí ";
            color: #00ff88;
            font-weight: 700;
        }

        .cmd {
            color: #ffaa00;
            font-weight: 700;
        }

        @media (max-width: 600px) {
            body { padding: 15px; }
            h1 { font-size: 1.5rem; }
            .mic-btn { width: 70px; height: 70px; font-size: 2rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé§ Voice Inventory</h1>
            <div class="status" id="status">Click mic to start</div>
        </div>

        <div class="mic-section">
            <button class="mic-btn" id="mic-btn" onclick="toggleMic()">üé§</button>
            <div class="transcript" id="transcript">...</div>
        </div>

        <div class="controls">
            <button class="control-btn" onclick="prevField()">‚¨ÖÔ∏è Back</button>
            <button class="control-btn" onclick="nextField()">Next ‚û°Ô∏è</button>
            <button class="control-btn" onclick="clearAll()">üóëÔ∏è Clear</button>
        </div>

        <div class="form">
            <div class="field-group active" id="field-0">
                <div class="field-label">
                    <span>Product Name</span>
                    <span class="field-number">1/5</span>
                </div>
                <input type="text" class="field-input" id="input-0" placeholder="Engine Oil...">
            </div>

            <div class="field-group" id="field-1">
                <div class="field-label">
                    <span>Category</span>
                    <span class="field-number">2/5</span>
                </div>
                <input type="text" class="field-input" id="input-1" placeholder="Lubricants...">
            </div>

            <div class="field-group" id="field-2">
                <div class="field-label">
                    <span>Unit</span>
                    <span class="field-number">3/5</span>
                </div>
                <input type="text" class="field-input" id="input-2" placeholder="Bottle...">
            </div>

            <div class="field-group" id="field-3">
                <div class="field-label">
                    <span>Price (‚Ç±)</span>
                    <span class="field-number">4/5</span>
                </div>
                <input type="text" class="field-input" id="input-3" placeholder="250">
            </div>

            <div class="field-group" id="field-4">
                <div class="field-label">
                    <span>Stock Quantity</span>
                    <span class="field-number">5/5</span>
                </div>
                <input type="text" class="field-input" id="input-4" placeholder="50">
            </div>
        </div>

        <button class="save-btn" id="save-btn" onclick="saveData()">üíæ SAVE TO SHEET</button>

        <div class="log">
            <div class="log-header" onclick="toggleLog()">
                <span style="font-weight:600">üìã Saved Items</span>
                <span class="log-count" id="log-count">0</span>
            </div>
            <div class="log-items" id="log-items"></div>
        </div>

        <div class="help">
            <h3>Voice Commands</h3>
            <ul>
                <li><span class="cmd">NEXT</span> - Move to next field</li>
                <li><span class="cmd">BACK</span> - Go back to previous field</li>
                <li><span class="cmd">DONE</span> - Save item</li>
                <li><span class="cmd">CLEAR</span> - Clear all fields</li>
                <li>Just speak naturally to fill fields</li>
            </ul>
        </div>
    </div>

    <script>
        // CONFIG
        const GOOGLE_SCRIPT_URL = "https://script.google.com/macros/s/AKfycbz6MKoHA1QNgDCfj42nMJgR7Ix42EuJH6vhxwa14oNUYlkJpOrXFxfa12P8VP38SJL0/exec";

        // SETUP
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if (!SpeechRecognition) {
            alert("‚ö†Ô∏è Voice recognition not supported. Use Chrome.");
        }

        const recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.lang = 'en-US';

        // STATE
        let listening = false;
        let currentField = 0;
        let saving = false;
        let savedItems = [];
        let lastCommand = '';
        let lastCommandTime = 0;

        let isAndroid = /android/i.test(navigator.userAgent);
        let micRestartAttempts = 0;
        const MAX_MIC_RESTARTS = 3;

        // ELEMENTS
        const micBtn = document.getElementById('mic-btn');
        const status = document.getElementById('status');
        const transcript = document.getElementById('transcript');
        const saveBtn = document.getElementById('save-btn');
        const logItems = document.getElementById('log-items');
        const logCount = document.getElementById('log-count');

        // LOAD SAVED ITEMS
        function loadItems() {
            const saved = localStorage.getItem('inventoryItems');
            if (saved) {
                savedItems = JSON.parse(saved);
                updateLog();
            }
        }

        function handleRecognitionEnd() {
            if (listening && !saving) {
                // Don't auto-restart on Android - we handle it manually
                if (!isAndroid) {
                    setTimeout(() => {
                        try {
                            recognition.start();
                        } catch (e) {
                            listening = false;
                            micBtn.classList.remove('listening');
                        }
                    }, 100);
                }
            }
        }

        // MIC CONTROL
        function toggleMic() {
            if (listening) {
                stopMic();
            } else {
                micRestartAttempts = 0; // Reset counter when user manually starts
                startMic();
            }
        }

        function startMic() {
            try {
                recognition.start();
                listening = true;
                micBtn.classList.add('listening');
                updateStatus();
            } catch (e) {
                console.log('Mic already running');
            }
        }

        function stopMic() {
            try {
                recognition.stop();
            } catch (e) {}
            listening = false;
            micBtn.classList.remove('listening');
            status.textContent = 'Paused';
        }

        function updateStatus() {
            const fields = ['Product Name', 'Category', 'Unit', 'Price', 'Stock'];
            status.textContent = `üé§ ${fields[currentField]}`;
        }

        // VOICE RECOGNITION
        handleVoiceResult = (event) => {
            if (saving) return;

            const result = event.results[event.results.length - 1];
            const text = result[0].transcript.trim();
            const lower = text.toLowerCase();
            const isFinal = result.isFinal;
            
            // Always show what's being heard (for user feedback)
            transcript.textContent = text;
            
            if (isFinal) {
                const now = Date.now();
                const timeSinceLastCommand = now - lastCommandTime;
                
                // CRITICAL FIX 1: Ignore results that come too quickly after a command
                // This prevents the "echo" effect where the same command gets processed twice
                if (timeSinceLastCommand < 500) {
                    console.log('Ignoring post-command speech fragment');
                    return;
                }
                
                // CRITICAL FIX 2: Better command detection with word boundaries
                const words = lower.split(/\s+/);
                const lastWord = words[words.length - 1];
                
                // Check if the last word is a command (allows "okay next" or "move next")
                if (lastWord === 'next' || lastWord === 'nex' || lastWord === 'text') {
                    // Also check if this is mostly a command (not a phrase that happens to end with "next")
                    if (words.length <= 2 || text.toLowerCase().includes('go next') || text.toLowerCase().includes('move next')) {
                        lastCommand = text;
                        lastCommandTime = now;
                        nextField();
                        
                        // CRITICAL FIX 3: Clear the transcript after a command
                        setTimeout(() => {
                            if (transcript.textContent === text) {
                                transcript.textContent = '...';
                            }
                        }, 300);
                        
                        return;
                    }
                }
                
                // CRITICAL FIX 4: More robust back command detection
                if (lastWord === 'back' || lastWord === 'previous' || 
                    text.toLowerCase().includes('go back') || 
                    text.toLowerCase().includes('move back')) {
                    lastCommand = text;
                    lastCommandTime = now;
                    prevField();
                    setTimeout(() => {
                        if (transcript.textContent === text) {
                            transcript.textContent = '...';
                        }
                    }, 300);
                    return;
                }
                
                // CRITICAL FIX 5: Clear detection
                if (lower.includes('clear') && (lower.includes('all') || words.length === 1)) {
                    lastCommand = text;
                    lastCommandTime = now;
                    clearAll();
                    setTimeout(() => {
                        if (transcript.textContent === text) {
                            transcript.textContent = '...';
                        }
                    }, 300);
                    return;
                }
                
                // CRITICAL FIX 6: Save detection
                if (lastWord === 'save' || lastWord === 'done' || 
                    text.toLowerCase().includes('save it') || 
                    text.toLowerCase().includes('all done')) {
                    lastCommand = text;
                    lastCommandTime = now;
                    saveData();
                    setTimeout(() => {
                        if (transcript.textContent === text) {
                            transcript.textContent = '...';
                        }
                    }, 300);
                    return;
                }
                
                // If we get here, it's not a command - fill the current field
                // BUT FIRST: Check if this looks like it might have been a failed command
                if (text.length < 10 && !/\d/.test(text)) {
                    // Short text without numbers might be a misheard command
                    const possibleCommands = ['next', 'back', 'clear', 'save', 'done'];
                    const similarity = possibleCommands.some(cmd => 
                        levenshteinDistance(lower, cmd) <= 2
                    );
                    
                    if (similarity) {
                        console.log('Ignoring possible misheard command:', text);
                        transcript.textContent = '...';
                        return;
                    }
                }
                
                // Actually fill the field
                fillField(text);
            }
        };

        function levenshteinDistance(a, b) {
            const matrix = [];
            
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }
            
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            
            return matrix[b.length][a.length];
        }

        // FILL FIELD
        function fillField(text) {
            const input = document.getElementById(`input-${currentField}`);
            let value = text.trim();
            
            // Don't fill if it's empty or just punctuation
            if (!value || value === '...' || /^[.,!?]+$/.test(value)) {
                return;
            }
            
            // Check for commands that might be misinterpreted as data
            const lower = value.toLowerCase();
            const commands = ['next', 'back', 'clear', 'save', 'done', 'previous'];
            
            // If it's a single word and matches a command (with some flexibility)
            if (commands.some(cmd => {
                return lower === cmd || 
                    lower.startsWith(cmd) || 
                    levenshteinDistance(lower, cmd) <= 1;
            })) {
                console.log('Blocked command from filling field:', value);
                return;
            }
            
            // SPECIAL: For price/stock fields, always try to parse as number
            if (currentField === 3 || currentField === 4) {
                // Try multiple parsing strategies
                const parsed = parseNumber(value);
                
                // If parsing gave us something different, use it
                if (parsed !== value && parsed !== '') {
                    input.value = parsed;
                    console.log(`Field ${currentField} parsed "${value}" ‚Üí "${parsed}"`);
                    return;
                }
                
                // Otherwise, use the original but clean it
                value = value.replace(/[^0-9.]/g, '');
                input.value = value;
                return;
            }
            
            // For text fields: uppercase first letter of each word
            if (currentField === 0 || currentField === 2) {
                value = value.split(' ')
                    .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                    .join(' ');
            }
            
            input.value = value;
            console.log(`Field ${currentField} set to: ${value}`);
        }

        // PARSE NUMBERS
        function parseNumber(text) {
            // Comprehensive number mapping
            const numberWords = {
                'zero': 0, 'oh': 0, 'o': 0,
                'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5,
                'six': 6, 'seven': 7, 'eight': 8, 'nine': 9,
                'ten': 10, 'eleven': 11, 'twelve': 12, 'thirteen': 13,
                'fourteen': 14, 'fifteen': 15, 'sixteen': 16,
                'seventeen': 17, 'eighteen': 18, 'nineteen': 19,
                'twenty': 20, 'thirty': 30, 'forty': 40, 'fifty': 50,
                'sixty': 60, 'seventy': 70, 'eighty': 80, 'ninety': 90,
                'hundred': 100, 'thousand': 1000, 'grand': 1000
            };

            let input = text.toLowerCase().trim();
            
            // Remove common non-number words that might appear
            input = input.replace(/and\s+/g, ' ')
                        .replace(/a\s+/g, ' ')
                        .replace(/the\s+/g, ' ')
                        .replace(/only\s+/g, ' ')
                        .replace(/just\s+/g, ' ')
                        .replace(/items?\s*/g, '')
                        .replace(/pcs?\s*/g, '')
                        .replace(/pieces?\s*/g, '')
                        .trim();

            console.log(`Parsing: "${text}" ‚Üí "${input}"`);

            // Direct numeric extraction first
            const directNumber = input.match(/\d+/);
            if (directNumber) {
                return directNumber[0];
            }

            // Handle "point five" for decimal
            if (input.includes('point')) {
                const parts = input.split('point');
                const whole = numberWords[parts[0].trim()] || 0;
                const decimalPart = parts[1].trim().split('').map(char => {
                    const num = numberWords[char];
                    return num !== undefined ? num : '';
                }).join('');
                return decimalPart ? `${whole}.${decimalPart}` : whole.toString();
            }

            // Split into words
            const words = input.split(/\s+|-/);
            let total = 0;
            let current = 0;

            for (let word of words) {
                const num = numberWords[word];
                
                if (num === undefined) {
                    // Try to extract embedded numbers like "five0" -> "50"
                    const embeddedNum = word.match(/\d+/);
                    if (embeddedNum) {
                        current = parseInt(embeddedNum[0], 10);
                        continue;
                    }
                    
                    // Skip non-number words
                    continue;
                }

                if (num >= 100) {
                    if (current === 0) current = 1;
                    current *= num;
                } else {
                    current += num;
                }
            }

            total += current;

            // If we found a number, return it
            if (total > 0) {
                return total.toString();
            }

            // Fallback: Try to extract any digits
            const fallbackDigits = text.replace(/[^0-9]/g, '');
            return fallbackDigits || text;
        }

        // NAVIGATION
        function nextField() {
            if (currentField < 4) {
                currentField++;
                highlightField(currentField);
            }
        }

        function prevField() {
            if (currentField > 0) {
                currentField--;
                highlightField(currentField);
            }
        }

        function highlightField(index) {
            // Remove active from all
            for (let i = 0; i < 5; i++) {
                document.getElementById(`field-${i}`).classList.remove('active');
            }
            // Add active to current
            document.getElementById(`field-${index}`).classList.add('active');
            // Scroll into view
            document.getElementById(`field-${index}`).scrollIntoView({
                behavior: 'smooth',
                block: 'center'
            });
            updateStatus();
        }

        // CLEAR
        function clearAll() {
            for (let i = 0; i < 5; i++) {
                document.getElementById(`input-${i}`).value = '';
            }
            currentField = 0;
            highlightField(0);
            transcript.textContent = '...';
        }

        // SAVE
        function saveData() {
            if (saving) return;

            const data = {
                name: document.getElementById('input-0').value,
                category: document.getElementById('input-1').value,
                unit: document.getElementById('input-2').value,
                price: document.getElementById('input-3').value,
                stock: document.getElementById('input-4').value,
                timestamp: new Date().toLocaleString()
            };

            if (!data.name) {
                alert('‚ùå Product name is required!');
                currentField = 0;
                highlightField(0);
                return;
            }

            saving = true;
            saveBtn.disabled = true;
            saveBtn.textContent = '‚è≥ Saving...';
            status.textContent = 'Saving to Google Sheets...';

            // Save to local log
            savedItems.unshift(data);
            localStorage.setItem('inventoryItems', JSON.stringify(savedItems));
            updateLog();

            // Send to Google Sheets
            fetch(GOOGLE_SCRIPT_URL, {
                method: 'POST',
                mode: 'no-cors',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            })
            .then(() => {
                finishSave(data);
            })
            .catch(err => {
                console.error('Save error:', err);
                finishSave(data);
            });

            // Timeout fallback
            setTimeout(() => {
                if (saving) finishSave(data);
            }, 3000);
        }

        function finishSave(data) {
            if (!saving) return;
            saving = false;

            status.textContent = `‚úÖ Saved: ${data.name}`;
            saveBtn.textContent = 'üíæ SAVE TO SHEET';
            saveBtn.disabled = false;
            transcript.textContent = '‚úÖ Item saved!';

            // Clear fields but preserve microphone state
            clearAll();

            // ANDROID-SPECIFIC FIX: Handle mic resurrection
            if (listening && isAndroid) {
                console.log('Android: Restarting mic after save...');
                
                // Step 1: Stop mic gracefully
                setTimeout(() => {
                    try {
                        recognition.stop();
                        recognition.onend = null; // Temporarily disable auto-restart
                    } catch (e) {
                        console.log('Android: Error stopping mic:', e);
                    }
                    
                    // Step 2: Wait for cleanup
                    setTimeout(() => {
                        micRestartAttempts = 0;
                        restartAndroidMic();
                    }, 500);
                }, 100);
            } else if (listening) {
                // Non-Android: Normal behavior
                setTimeout(() => {
                    if (listening) {
                        updateStatus();
                        transcript.textContent = '...';
                    }
                }, 2000);
            }
        }

        // NEW: Dedicated Android mic restarter
        function restartAndroidMic() {
            if (!listening || micRestartAttempts >= MAX_MIC_RESTARTS) {
                console.log('Android: Max restart attempts reached or not listening');
                listening = false;
                micBtn.classList.remove('listening');
                return;
            }

            micRestartAttempts++;
            console.log(`Android: Mic restart attempt ${micRestartAttempts}`);

            // Force stop any existing instance
            try {
                recognition.stop();
            } catch (e) {}

            // Create a fresh recognition instance for Android
            setTimeout(() => {
                try {
                    // Re-setup the recognition event handlers
                    setupRecognition();
                    
                    // Start fresh
                    recognition.start();
                    
                    // Give it time to initialize
                    setTimeout(() => {
                        if (recognition && listening) {
                            console.log('Android: Mic successfully restarted');
                            status.textContent = '‚úÖ Mic restored';
                            setTimeout(() => updateStatus(), 1000);
                        }
                    }, 300);
                } catch (error) {
                    console.log('Android: Failed to restart mic:', error);
                    
                    // Exponential backoff retry
                    if (micRestartAttempts < MAX_MIC_RESTARTS) {
                        setTimeout(() => restartAndroidMic(), 1000 * micRestartAttempts);
                    }
                }
            }, 200);
        }

        // NEW: Setup recognition separately for easy recreation
        function setupRecognition() {
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.lang = 'en-US';
            
            // Reattach event handlers
            recognition.onresult = handleVoiceResult;
            recognition.onend = handleRecognitionEnd;
            recognition.onerror = handleRecognitionError;
        }

        // LOG
        function toggleLog() {
            logItems.classList.toggle('open');
        }

        function updateLog() {
            logCount.textContent = savedItems.length;

            if (savedItems.length === 0) {
                logItems.innerHTML = '<div style="padding:20px;text-align:center;color:#666">No items yet</div>';
                return;
            }

            logItems.innerHTML = savedItems.slice(0, 20).map(item => `
                <div class="log-item">
                    <div class="log-item-name">${item.name}</div>
                    <div class="log-item-details">
                        ${item.category} ‚Ä¢ ${item.unit} ‚Ä¢ ‚Ç±${item.price} ‚Ä¢ Qty: ${item.stock}
                    </div>
                </div>
            `).join('');
        }

        // ERROR HANDLING
        recognition.onend = () => {
            if (listening && !saving) {
                setTimeout(() => {
                    try {
                        recognition.start();
                    } catch (e) {
                        listening = false;
                        micBtn.classList.remove('listening');
                    }
                }, 100);
            }
        };

        recognition.onerror = (event) => {
            if (event.error === 'not-allowed') {
                alert('‚ö†Ô∏è Please allow microphone access');
                listening = false;
                micBtn.classList.remove('listening');
            }
        };

        // INITIALIZE
        loadItems();
        highlightField(0);
    </script>
</body>
</html>
